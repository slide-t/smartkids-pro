<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SmartKids Pro | Mouse Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background: #eef3fb;
      overflow: hidden;
    }

    /* Header */
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(90deg, #0078ff, #0059c1);
      color: white;
      padding: 10px 20px;
      font-size: 1.2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      position: relative;
      z-index: 20;
    }

    header .brand {
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .brand span {
      animation: glow 2s infinite alternate;
    }

    @keyframes glow {
      from { text-shadow: 0 0 5px #fff, 0 0 10px #6ec1ff; }
      to { text-shadow: 0 0 10px #fff, 0 0 20px #7ed6ff; }
    }

    .home-btn {
      background: white;
      color: #0078ff;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 600;
      text-decoration: none;
      transition: all 0.3s ease;
    }
    .home-btn:hover { background: #e8f1ff; }

    /* Sidebar */
    .sidebar {
      position: fixed;
      right: 0;
      top: 0;
      width: 220px;
      height: 100vh;
      background: #f4f6fb;
      padding: 80px 15px 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto;
      transition: transform 0.4s ease;
      z-index: 15;
    }

    .sidebar.hidden {
      transform: translateX(230px);
    }

    .menu-toggle {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      width: 24px;
      height: 18px;
      cursor: pointer;
    }

    .menu-toggle span {
      height: 3px;
      background: white;
      border-radius: 2px;
      transition: 0.3s;
    }

    .menu-toggle:hover span:nth-child(2) {
      width: 70%;
    }

    /* Sidebar buttons */
    .mode-btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s, opacity 0.3s;
    }
    .mode-btn:hover { transform: scale(1.05); opacity: 0.9; }

    .green { background: #28a745; }
    .blue { background: #0078ff; }
    .purple { background: #7e57c2; }
    .orange { background: #ff9800; }
    .yellow { background: #fdd835; color: #333; }
    .gray { background: #9e9e9e; }
    .brown { background: #795548; }
    .red { background: #e53935; }

    /* Main Game Board */
    .main-board {
      margin-right: 240px;
      height: calc(100vh - 60px);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .circle {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: #28a745;
      cursor: pointer;
      transition: background 0.3s, transform 0.1s;
    }
    .circle:active { transform: scale(0.9); }

    /* Controls */
    .controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      gap: 10px;
    }

    .control-btn {
      padding: 8px 14px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      color: white;
      background: #0078ff;
    }

    /* Timer + Selector */
    .timer-wrapper {
      position: absolute;
      top: 10px;
      left: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      background: white;
      padding: 5px 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      font-weight: 600;
    }

    #timeSelector {
      background: #f8faff;
      color: #0078ff;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 6px;
      border: 2px solid #0078ff;
      cursor: pointer;
      transition: 0.3s ease;
    }
    #timeSelector:hover {
      background: #0078ff;
      color: white;
    }

    /* Menu icon animation */
    #menuToggle.active span:nth-child(1) {
      transform: rotate(45deg) translateY(8px);
    }
    #menuToggle.active span:nth-child(2) {
      opacity: 0;
    }
    #menuToggle.active span:nth-child(3) {
      transform: rotate(-45deg) translateY(-8px);
    }
    #menuToggle span { transition: all 0.3s ease; }

    /*new update*/
    .game-area {
  position: relative;
  width: 80%;
  max-width: 900px;
  height: 75%;
  margin: auto;
  background: #ffffff;
  border: 2px dashed #0078ff33;
  border-radius: 15px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  aspect-ratio: 4 / 3;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Fix timer position so tooltip never covers it */
.timer-wrapper {
  top: 12px;
  left: 16px;
  z-index: 5;
}
  </style>
</head>
<body>
  <header>
    <div class="brand">
      üê≠ <span>SmartKids Mouse Practice</span>
    </div>
    <div style="display: flex; align-items: center; gap: 15px;">
      <a href="index.html" class="home-btn">üè† Home</a>
      <div class="menu-toggle" id="menuToggle" title="Toggle Menu">
        <span></span><span></span><span></span>
      </div>
    </div>
  </header>

  <!-- Sidebar -->
  <div class="sidebar hidden" id="sidebar">
    <button class="mode-btn green" data-mode="click">Click Targets</button>
    <button class="mode-btn blue" data-mode="double">Double Click Test</button>
    <button class="mode-btn purple" data-mode="drag">Drag & Drop</button>
    <button class="mode-btn orange" data-mode="speed">Speed Tracker</button>
    <button class="mode-btn yellow" data-mode="shape">Shape Builder</button>
    <button class="mode-btn gray" data-mode="draw">Drawing Pad</button>
    <button class="mode-btn brown" data-mode="reflex">Reflex Game</button>
    <button class="mode-btn red" data-mode="memory">Memory Match</button>
  </div>

<!-- Main Game Area -->
<div class="main-board" id="gameBoard">
  <div class="timer-wrapper">
    <div class="timer" id="timer">Time: 15</div>
    <select id="timeSelector">
      <option value="15">15s</option>
      <option value="20">20s</option>
      <option value="25">25s</option>
    </select>
  </div>

  <!-- New dedicated play area -->
  <div class="game-area" id="gameArea"></div>

  <div class="controls">
    <button class="control-btn" id="startBtn">Start</button>
    <button class="control-btn" id="pauseBtn">Pause</button>
    <button class="control-btn" id="resetBtn">Reset</button>
  </div>
</div>

  <script>
document.addEventListener("DOMContentLoaded", () => {
  const gameArea = document.getElementById("gameArea");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resetBtn = document.getElementById("resetBtn");
  const timerDisplay = document.getElementById("timer");
  const timeSelector = document.getElementById("timeSelector");
  const sidebar = document.getElementById("sidebar");
  const menuToggle = document.getElementById("menuToggle");

  let circle = null;
  let timeLeft = parseInt(timeSelector.value);
  let timer;
  let score = 0;
  let isPaused = false;
  let isRunning = false;

  // üéØ Create floating score tooltip
  const scoreDisplay = document.createElement("div");
  scoreDisplay.style.position = "absolute";
  scoreDisplay.style.top = "10px";
  scoreDisplay.style.right = "15px";
  scoreDisplay.style.background = "#0078ff";
  scoreDisplay.style.color = "#fff";
  scoreDisplay.style.padding = "6px 12px";
  scoreDisplay.style.borderRadius = "8px";
  scoreDisplay.style.fontWeight = "600";
  scoreDisplay.style.boxShadow = "0 2px 6px rgba(0,0,0,0.2)";
  scoreDisplay.style.zIndex = "6";
  scoreDisplay.textContent = "Score: 0";
  gameArea.appendChild(scoreDisplay);

  // Sidebar toggle animation
  menuToggle.addEventListener("click", () => {
    sidebar.classList.toggle("hidden");
    menuToggle.classList.toggle("active");
  });

  // Timer dropdown change
  timeSelector.addEventListener("change", () => {
    if (!isRunning) {
      timeLeft = parseInt(timeSelector.value);
      timerDisplay.textContent = `Time: ${timeLeft}`;
    }
  });

  // ‚ñ∂Ô∏è Start Game
  startBtn.addEventListener("click", () => {
    if (isRunning) return;
    isRunning = true;
    isPaused = false;
    score = 0;
    updateScore();
    timeLeft = parseInt(timeSelector.value);
    timerDisplay.textContent = `Time: ${timeLeft}`;
    spawnCircle();
    timer = setInterval(updateTimer, 1000);
  });

  // ‚è∏ Pause or Resume Game
  pauseBtn.addEventListener("click", () => {
    if (!isRunning) return;
    isPaused = !isPaused;
    pauseBtn.textContent = isPaused ? "Resume" : "Pause";
  });

  // üîÅ Reset Game
  resetBtn.addEventListener("click", resetGame);

  function resetGame() {
    clearInterval(timer);
    if (circle) circle.remove();
    isRunning = false;
    isPaused = false;
    score = 0;
    updateScore();
    timeLeft = parseInt(timeSelector.value);
    timerDisplay.textContent = `Time: ${timeLeft}`;
    pauseBtn.textContent = "Pause";
  }

  function updateTimer() {
    if (isPaused) return;
    timeLeft--;
    timerDisplay.textContent = `Time: ${timeLeft}`;
    if (timeLeft <= 0) endGame();
  }

  function endGame() {
    clearInterval(timer);
    if (circle) circle.remove();
    isRunning = false;
    alert(`‚è∞ Time's up! Your score: ${score}`);
  }

  // üéØ Circle Spawning Logic
  function spawnCircle() {
    if (circle) circle.remove();
    circle = document.createElement("div");
    circle.classList.add("circle");
    gameArea.appendChild(circle);
    moveCircleWithinBounds();

    circle.addEventListener("click", () => {
      if (!isRunning || isPaused) return;
      score++;
      updateScore();
      changeCircleColor();
      moveCircleWithinBounds();
    });
  }

  // üü¢ Move circle within safe area
  function moveCircleWithinBounds() {
    const areaRect = gameArea.getBoundingClientRect();
    const size = 60;
    const padding = 10;
    const maxX = areaRect.width - size - padding;
    const maxY = areaRect.height - size - padding;
    const randomX = Math.random() * maxX + padding;
    const randomY = Math.random() * maxY + padding;

    circle.style.left = `${randomX}px`;
    circle.style.top = `${randomY}px`;
  }

  // üåà Random color changer
  function changeCircleColor() {
    const colors = ["#28a745", "#ff9800", "#f44336", "#0078ff", "#9c27b0", "#795548", "#00bcd4"];
    const randomColor = colors[Math.floor(Math.random() * colors.length)];
    circle.style.background = randomColor;
  }

  // üíØ Score updater
  function updateScore() {
    scoreDisplay.textContent = `Score: ${score}`;
  }
});
</script>
  
  <!--<script>
/*
  Enhanced SmartKids Mouse Practice script
  - Requires: json-files/mouse_lessons.json (confirmed path)
  - Implements: Click Practice, Double Click Practice, Drag & Drop
  - Keeps your HTML/CSS exactly as provided
*/

(() => {
  // DOM refs (existing in page)
  const gameBoard = document.getElementById("gameBoard");
  const timerDisplay = document.getElementById("timer");
  const sidebar = document.getElementById("sidebar");
  const menuToggle = document.getElementById("menuToggle");
  const timeSelector = document.getElementById("timeSelector");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resetBtn = document.getElementById("resetBtn");

  // State
  let lessonsData = {};
  let currentMode = null;
  let currentLevel = null;
  let currentLesson = null; // JSON lesson object
  let gameRunning = false;
  let paused = false;
  let timer = 0;
  let timerInterval = null;
  let activeElements = []; // DOM nodes to cleanup
  let score = 0;
  let hits = 0;

  // --- Utility helpers ---
  function qs(sel, root=document) { return root.querySelector(sel); }
  function qsa(sel, root=document) { return Array.from(root.querySelectorAll(sel)); }
  function clearActive() { activeElements.forEach(el => el.remove()); activeElements = []; }
  function stopTimer() { if (timerInterval) { clearInterval(timerInterval); timerInterval = null; } }
  function lockTimeSelector(lock) { timeSelector.disabled = !!lock; }
  function setTimerDisplay(t) { timerDisplay.textContent = `Time: ${t}`; }
  function hideSidebar() { sidebar.classList.add('hidden'); menuToggle.classList.remove('active'); }
  function showOverlay(html) {
    // create a centered floating overlay with content html
    const overlay = document.createElement('div');
    overlay.className = 'sk-overlay';
    overlay.style = `
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%,-50%);
      background: white;
      color: #0b1220;
      padding: 18px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.2);
      z-index: 50;
      max-width: min(760px, 90%);
      width: calc(600px);
      text-align: left;
    `;
    overlay.innerHTML = html;
    gameBoard.appendChild(overlay);
    activeElements.push(overlay);
    return overlay;
  }

  // --- Build sidebar from JSON (preserve container) ---
  function buildSidebarFromJSON() {
    // if lessonsData not yet loaded, keep existing buttons; call again after fetch
    if (!lessonsData || Object.keys(lessonsData).length === 0) return;
    // Flatten modes across years for sidebar listing (first occurrence per mode)
    const seen = new Set();
    const btns = [];
    Object.entries(lessonsData).forEach(([year, lessons]) => {
      Object.keys(lessons).forEach(modeName => {
        const key = modeName.toLowerCase().replace(/\s+/g,'-');
        if (!seen.has(modeName)) {
          seen.add(modeName);
          btns.push({ modeName, key, year });
        }
      });
    });

    // clear existing sidebar content but keep container
    sidebar.innerHTML = '';
    // put header
    const h = document.createElement('h3');
    h.textContent = 'üñ±Ô∏è Mouse Practices';
    h.style.margin = '0 0 8px 0';
    h.style.color = '#0b1220';
    h.style.fontWeight = 700;
    sidebar.appendChild(h);

    // Create buttons (preserve your color order)
    const colors = ['green','blue','purple','orange','yellow','gray','brown','red'];
    btns.forEach((b, i) => {
      const btn = document.createElement('button');
      btn.className = `mode-btn ${colors[i % colors.length]}`;
      btn.dataset.mode = b.modeName.toLowerCase().replace(/\s+/g,'_'); // normalized key
      btn.textContent = b.modeName;
      btn.dataset.year = b.year;
      btn.style.textAlign = 'left';
      btn.addEventListener('click', () => {
        // hide sidebar, toggle icon back
        hideSidebar();
        // load lesson data and show overlay with levels
        loadLessonAndShow(b.year, b.modeName);
      });
      sidebar.appendChild(btn);
    });
  }

  // --- Load lessons JSON ---
  fetch('json-files/mouse_lessons.json')
    .then(res => res.json())
    .then(data => {
      lessonsData = data;
      buildSidebarFromJSON();
      console.log('mouse_lessons.json loaded');
    })
    .catch(err => {
      console.error('Error loading mouse_lessons.json:', err);
      // fallback: leave current hard-coded buttons active
    });

  // --- Menu toggle animation (preserve existing) ---
  menuToggle.addEventListener('click', () => {
    sidebar.classList.toggle('hidden');
    menuToggle.classList.toggle('active');
  });

  // --- Overlay + Level selector ---
  function loadLessonAndShow(year, lessonName) {
    const yearNode = lessonsData[year];
    if (!yearNode || !yearNode[lessonName]) {
      // fallback: try to find lesson across years
      let found = null; for (const y of Object.keys(lessonsData||{})) {
        if (lessonsData[y][lessonName]) { found = { year: y, lesson: lessonsData[y][lessonName] }; break; }
      }
      if (!found) return alert('Lesson not found in JSON.');
      currentLesson = found.lesson;
    } else {
      currentLesson = yearNode[lessonName];
    }
    currentMode = lessonName;
    // Build overlay content
    const levels = currentLesson.levels || [];
    let lvlButtons = levels.map((lv, idx) => `<button class="sk-lvl-btn" data-idx="${idx}" style="margin-right:8px;padding:8px 12px;border-radius:8px;border:2px solid #0b1220;background:#fff;font-weight:700;cursor:pointer">${lv.name}</button>`).join('');
    if (!lvlButtons) lvlButtons = `<em>No levels defined</em>`;
    const html = `
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="font-size:20px;font-weight:800;margin-bottom:6px">${lessonName} ‚Äî ${year}</div>
          <div style="color:#334155;margin-bottom:12px">${currentLesson.instructions || ''}</div>
        </div>
        <div style="text-align:right">
          <div style="font-size:12px;color:#64748b">Choose level</div>
          <div style="margin-top:6px">${lvlButtons}</div>
        </div>
      </div>
      <div style="margin-top:14px;display:flex;justify-content:flex-end;gap:10px">
        <button id="sk-cancel" style="padding:8px 14px;border-radius:8px;border:1px solid #cbd5e1;background:#fff">Cancel</button>
        <button id="sk-start" style="padding:8px 14px;border-radius:8px;border:0;background:#0b1220;color:white;font-weight:800">Start Selected</button>
      </div>
    `;
    const overlay = showOverlay(html);
    // attach handlers
    let selectedLevelIndex = 0;
    qsa('.sk-lvl-btn', overlay).forEach(btn => {
      btn.addEventListener('click', (e) => {
        qsa('.sk-lvl-btn', overlay).forEach(b => b.style.boxShadow='none');
        btn.style.boxShadow = '0 6px 18px rgba(15,23,42,0.12)';
        selectedLevelIndex = parseInt(btn.dataset.idx);
      });
    });
    // default first
    const firstBtn = qs('.sk-lvl-btn', overlay);
    if (firstBtn) { firstBtn.style.boxShadow = '0 6px 18px rgba(15,23,42,0.12)'; selectedLevelIndex = 0; }

    qs('#sk-cancel', overlay).addEventListener('click', () => { overlay.remove(); activeElements = activeElements.filter(a=>a!==overlay); });
    qs('#sk-start', overlay).addEventListener('click', () => {
      overlay.remove(); activeElements = activeElements.filter(a=>a!==overlay);
      // start selected level
      currentLevel = (currentLesson.levels && currentLesson.levels[selectedLevelIndex]) || null;
      startSelectedMode();
    });
  }

  // --- Start the chosen mode (delegator) ---
  function startSelectedMode() {
    clearActive();
    stopTimer();
    paused = false;
    score = 0; hits = 0;

    if (!currentLesson) return alert('No lesson selected.');
    const name = currentMode.toLowerCase();
    // map common names to implemented functions
    if (name.includes('click')) {
      runClickPractice(currentLevel);
    } else if (name.includes('double')) {
      runDoubleClickPractice(currentLevel);
    } else if (name.includes('drag')) {
      runDragAndDrop(currentLevel);
    } else {
      alert(`üîß "${currentMode}" will be available soon.`);
    }
  }

  // --- Common timer flow ---
  function beginTimer(duration, onTick, onEnd) {
    timer = duration;
    setTimerDisplay(timer);
    stopTimer();
    timerInterval = setInterval(() => {
      if (!paused) {
        timer--;
        setTimerDisplay(timer);
        onTick && onTick(timer);
        if (timer <= 0) {
          stopTimer();
          onEnd && onEnd();
        }
      }
    }, 1000);
  }

  // --- Game: Click Practice (targets) ---
  function runClickPractice(level) {
    // level: {name, time, targets}
    const lvlTime = (level && level.time) || parseInt(timeSelector.value) || 15;
    const totalTargets = (level && level.targets) || 8;
    lockTimeSelector(true);
    // display scoreboard area
    const status = document.createElement('div');
    status.style = 'position:absolute;right:20px;top:20px;background:#fff;padding:8px 12px;border-radius:8px;font-weight:700;color:#0b1220;z-index:40';
    status.textContent = `Score: 0 ‚Ä¢ Hits: 0/${totalTargets}`;
    gameBoard.appendChild(status); activeElements.push(status);

    function spawnTarget() {
      const t = document.createElement('div');
      t.className = 'circle';
      t.style.width = '60px';
      t.style.height = '60px';
      t.style.background = '#ef4444';
      t.style.left = (Math.random() * (gameBoard.clientWidth - 80)) + 'px';
      t.style.top = (Math.random() * (gameBoard.clientHeight - 120)) + 'px';
      t.style.zIndex = 30;
      gameBoard.appendChild(t);
      activeElements.push(t);

      // auto-remove target after short time
      const ttl = 1400;
      const timeoutId = setTimeout(()=> { if (t.parentNode) { t.remove(); activeElements = activeElements.filter(a=>a!==t);} }, ttl);

      t.addEventListener('click', function handler() {
        if (paused) return;
        clearTimeout(timeoutId);
        hits++;
        score += 10;
        // change color progression
        if (hits >= 3 && hits < 6) t.style.background = '#ff9800';
        else if (hits >= 6 && hits < 10) t.style.background = '#0078ff';
        else if (hits >= 10) t.style.background = '#28a745';
        t.remove();
        activeElements = activeElements.filter(a=>a!==t);
        status.textContent = `Score: ${score} ‚Ä¢ Hits: ${hits}/${totalTargets}`;
        // spawn next if not finished
        if (hits < totalTargets) setTimeout(spawnTarget, 350);
      }, { once:true });
    }

    // start flow
    spawnTarget();
    beginTimer(lvlTime, null, () => {
      // game end
      lockTimeSelector(false);
      cleanupAfterGame();
      status.textContent = `Final score: ${score} ‚Ä¢ Hits: ${hits}/${totalTargets}`;
      setTimeout(()=> alert(`Time's up ‚Äî Click Practice finished.\nScore: ${score}`), 150);
    });
  }

  // --- Game: Double Click Practice ---
  function runDoubleClickPractice(level) {
    // level: {name, time, targets}
    const lvlTime = (level && level.time) || parseInt(timeSelector.value) || 15;
    const totalTargets = (level && level.targets) || 6;
    lockTimeSelector(true);

    const info = document.createElement('div');
    info.style = 'position:absolute;right:20px;top:20px;background:#fff;padding:8px 12px;border-radius:8px;font-weight:700;color:#0b1220;z-index:40';
    info.textContent = `Double-click targets: 0/${totalTargets}`;
    gameBoard.appendChild(info); activeElements.push(info);

    function spawnShape() {
      const box = document.createElement('div');
      box.style = 'position:absolute;width:72px;height:72px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:800;color:#fff;cursor:pointer;z-index:30';
      // random color and shape char
      const colors = ['#ef4444','#f97316','#60a5fa','#c084fc','#10b981'];
      box.style.background = colors[Math.floor(Math.random()*colors.length)];
      box.style.left = (Math.random() * (gameBoard.clientWidth - 100)) + 'px';
      box.style.top = (Math.random() * (gameBoard.clientHeight - 140)) + 'px';
      gameBoard.appendChild(box); activeElements.push(box);

      let clickedOnce = false;
      const singleTimeout = 800; // allow double-click time window
      let singleTimer = null;

      box.addEventListener('click', () => {
        if (paused) return;
        if (!clickedOnce) {
          clickedOnce = true;
          singleTimer = setTimeout(()=>{
            // treated as single click (miss)
            clickedOnce = false;
            box.remove();
            activeElements = activeElements.filter(a=>a!==box);
            // spawn next
            spawnShape();
          }, singleTimeout);
        } else {
          // double click success
          clearTimeout(singleTimer);
          hits++;
          score += 15;
          info.textContent = `Double-click targets: ${hits}/${totalTargets}`;
          box.remove(); activeElements = activeElements.filter(a=>a!==box);
          if (hits < totalTargets) spawnShape();
        }
      }, { passive:true });
      // safety removal
      setTimeout(()=>{ if (box.parentNode) { box.remove(); activeElements = activeElements.filter(a=>a!==box); if (hits < totalTargets) spawnShape(); } }, 1500);
    }

    // first spawn
    spawnShape();
    beginTimer(lvlTime, null, () => {
      lockTimeSelector(false);
      cleanupAfterGame();
      setTimeout(()=> alert(`Double Click Practice ended.\nScore: ${score} ‚Ä¢ Hits: ${hits}/${totalTargets}`), 120);
    });
  }

  // --- Game: Drag & Drop ---
  function runDragAndDrop(level) {
    // level: { name, items }
    const itemsCount = (level && level.items) || 4;
    lockTimeSelector(true);

    // Create containers: left side draggable items, right side drop targets
    const container = document.createElement('div');
    container.style = 'position:absolute;inset:60px 40px 80px 40px;display:flex;gap:20px;align-items:center;justify-content:center;z-index:20';
    const left = document.createElement('div'); left.style = 'flex:1;display:flex;flex-wrap:wrap;gap:12px;align-content:flex-start;justify-content:center;padding:12px;border-radius:10px;background:#f8fafc;';
    const right = document.createElement('div'); right.style = 'flex:1;display:grid;grid-template-columns:repeat(2,1fr);gap:12px;padding:12px;border-radius:10px;background:#fff;align-content:center;justify-items:center;';
    container.appendChild(left); container.appendChild(right);
    gameBoard.appendChild(container); activeElements.push(container);

    // sample set: use emoji or letters to match
    const sample = [];
    for (let i=0;i<itemsCount;i++){
      const label = String.fromCharCode(65 + i); // A,B,C...
      sample.push({ id: 'it-'+i, label });
    }
    // shuffle
    const shuffled = sample.slice().sort(()=>Math.random()-0.5);

    // build draggable items
    shuffled.forEach(it => {
      const el = document.createElement('div');
      el.textContent = it.label;
      el.draggable = true;
      el.style = 'width:80px;height:60px;border-radius:8px;background:#0ea5a5;color:white;display:flex;align-items:center;justify-content:center;font-weight:800;cursor:grab';
      el.dataset.id = it.id;
      left.appendChild(el); activeElements.push(el);

      el.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', it.id);
        setTimeout(()=> el.style.opacity = '0.4', 10);
      });
      el.addEventListener('dragend', () => { el.style.opacity = '1'; });
    });

    // build drop targets in correct order but visually shuffled
    const targets = sample.slice().sort(()=>Math.random()-0.5);
    let correctCount = 0;
    targets.forEach(t => {
      const slot = document.createElement('div');
      slot.style = 'width:100px;height:70px;border:2px dashed #94a3b8;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:800;color:#0b1220;background:#f8fafc';
      slot.dataset.accept = t.id;
      slot.textContent = '?';
      right.appendChild(slot); activeElements.push(slot);

      slot.addEventListener('dragover', (e) => { e.preventDefault(); slot.style.background = '#e6fffa'; });
      slot.addEventListener('dragleave', () => { slot.style.background = '#f8fafc'; });
      slot.addEventListener('drop', (e) => {
        e.preventDefault();
        const droppedId = e.dataTransfer.getData('text/plain');
        if (droppedId === slot.dataset.accept) {
          // correct
          slot.style.background = '#bbf7d0';
          slot.textContent = t.label;
          // remove the draggable item
          const orig = qsa(`[data-id="${droppedId}"]`)[0];
          if (orig) { orig.remove(); activeElements = activeElements.filter(a=>a!==orig); }
          correctCount++;
          if (correctCount >= itemsCount) {
            // success
            cleanupAfterGame();
            lockTimeSelector(false);
            alert(`Well done ‚Äî Drag & Drop complete!`);
          }
        } else {
          // wrong: small shake
          slot.style.background = '#fecaca';
          setTimeout(()=> slot.style.background = '#f8fafc', 350);
        }
      });
    });

    // Timer: optional (use timeSelector or per-level later)
    const lvlTime = parseInt(timeSelector.value) || 30;
    beginTimer(lvlTime, null, () => {
      lockTimeSelector(false);
      cleanupAfterGame();
      alert(`Time's up ‚Äî Drag & Drop ended.`);
    });
  }

  // --- Cleanup after any game ---
  function cleanupAfterGame() {
    stopTimer();
    // remove all active nodes we added
    activeElements.forEach(el => { if (el && el.parentNode) el.remove(); });
    activeElements = [];
    lockTimeSelector(false);
    gameRunning = false;
    paused = false;
    score = 0; hits = 0;
    setTimerDisplay( parseInt(timeSelector.value) || 15 );
  }

  // --- Controls (Start/Pause/Reset) ---
  startBtn.addEventListener('click', () => {
    // If a mode loaded via sidebar, startSelectedMode will be invoked by overlay; but allow quick start for currently selected JSON mode
    if (gameRunning) return;
    // If no mode selected, fallback to Click practice
    if (!currentMode) {
      // pick Click Practice from JSON Year 1 if present, else fallback
      if (lessonsData['Year 1'] && lessonsData['Year 1']['Click Practice']) {
        currentMode = 'Click Practice';
        currentLesson = lessonsData['Year 1']['Click Practice'];
        currentLevel = currentLesson.levels && currentLesson.levels[0];
        startSelectedMode();
        return;
      }
    }
    // else if selected, start overlay flow
    if (currentMode && currentLesson) {
      // if overlay/pick hasn't occurred, just start selected mode (use currentLevel if set)
      if (!currentLevel && currentLesson.levels && currentLesson.levels[0]) currentLevel = currentLesson.levels[0];
      startSelectedMode();
    } else {
      // fallback
      startSelectedMode();
    }
  });

  pauseBtn.addEventListener('click', () => {
    if (!gameRunning) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if (paused) {
      stopTimer();
    } else {
      // resume timer with remaining value
      beginTimer(timer, null, () => {
        // when resumed timer hits zero
        cleanupAfterGame();
        alert('Time ended.');
      });
    }
  });

  resetBtn.addEventListener('click', () => {
    // reload basic state but do not reload page
    cleanupAfterGame();
    currentMode = null; currentLevel = null; currentLesson = null;
    setTimerDisplay(parseInt(timeSelector.value) || 15);
  });

  // set initial timer display
  setTimerDisplay(parseInt(timeSelector.value) || 15);

  // ensure sidebar build attempts after load (in case JSON loads after)
  setTimeout(buildSidebarFromJSON, 600);

  // expose small debug on console
  window.SmartKidsMouse = {
    lessonsData,
    startSelectedMode,
    cleanupAfterGame
  };

})();
</script>-->
  
</body>
</html>
